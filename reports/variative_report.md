# Создание собственного движка регулярных выражений на Scala

## Исследование предметной области

### Обзор

В этой серии статей рассматривается процесс создания движка регулярных выражений, включающий:

1. Парсинг регулярного выражения в синтаксическое дерево.
2. Преобразование синтаксического дерева в недетерминированный конечный автомат (NFA).
3. Оценка NFA для проверки соответствия строки регулярному выражению.

Этот подход основан на алгоритме, предложенном Кеном Томпсоном, и обеспечивает эффективную обработку регулярных выражений без использования обратного отслеживания.

## Техническое руководство

### Поддерживаемые конструкции регулярных выражений

Поддерживаются следующие конструкции:

- `.` — соответствует любому символу.
- `|` — альтернатива (например, `a|b`).
- `+` — один или более повторений предыдущего шаблона.
- `*` — ноль или более повторений предыдущего шаблона.
- `()` — группировка выражений.

### Этап 1: Парсинг регулярного выражения

Сначала необходимо преобразовать строку регулярного выражения в абстрактное синтаксическое дерево (AST).

```scala
sealed trait RegexExpr
case class Literal(c: Char) extends RegexExpr
case class Or(expr1: RegexExpr, expr2: RegexExpr) extends RegexExpr
case class Concat(first: RegexExpr, second: RegexExpr) extends RegexExpr
case class Repeat(expr: RegexExpr) extends RegexExpr
case class Plus(expr: RegexExpr) extends RegexExpr
```

### Этап 2: Построение недетерминированного конечного автомата (NFA)

После того как регулярное выражение распарсено в абстрактное синтаксическое дерево (AST), следующим шагом будет построение **недетерминированного конечного автомата (NFA)**. Этот автомат позволяет эффективно проверять соответствие строки шаблону.

NFA состоит из:

- множества состояний,
- переходов между ними,
- стартового состояния,
- множества конечных состояний.

Каждое регулярное выражение можно рекурсивно преобразовать в NFA. Для этого определим представление автомата:

```scala
case class State(
  id: Int,
  var transitions: List[(Option[Char], State)] = List()
)

case class NFA(start: State, accept: State)
```

### Этап 3: Оценка NFA

Для проверки соответствия строки регулярному выражению используется следующий алгоритм:

1. Начать с начального состояния NFA.
2. Для каждого символа входной строки:
   - Определить все возможные переходы без потребления символа (ε-переходы).
   - Перейти в новые состояния, соответствующие текущему символу.
3. Если после обработки всех символов достигнуто состояние совпадения, строка соответствует выражению.

```scala
object NFAEvaluator {
  def evaluate(nfa: State, input: String): Boolean = {
    def eval(states: Set[State], chars: List[Char]): Boolean = chars match {
      case Nil => states.exists(_.isMatch)
      case c :: cs =>
        val nextStates = states.flatMap(_.transitions(c))
        eval(nextStates, cs)
    }
    eval(Set(nfa), input.toList)
  }
}
```

---
[Видео-демонстрация работы движка](./variative_presentation.MOV)

